
EasyAVR128_W5100.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  00000918  000009ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000918  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000216  00800116  00800116  000009c2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000009c2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000009f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e0  00000000  00000000  00000a34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000156d  00000000  00000000  00000b14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000053a  00000000  00000000  00002081  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bcc  00000000  00000000  000025bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002c4  00000000  00000000  00003188  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000add8  00000000  00000000  0000344c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000ef1  00000000  00000000  0000e224  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  0000f115  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000033be  00000000  00000000  0000f1ed  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	4e c0       	rjmp	.+156    	; 0x9e <__ctors_end>
   2:	00 00       	nop
   4:	69 c0       	rjmp	.+210    	; 0xd8 <__bad_interrupt>
   6:	00 00       	nop
   8:	67 c0       	rjmp	.+206    	; 0xd8 <__bad_interrupt>
   a:	00 00       	nop
   c:	65 c0       	rjmp	.+202    	; 0xd8 <__bad_interrupt>
   e:	00 00       	nop
  10:	63 c0       	rjmp	.+198    	; 0xd8 <__bad_interrupt>
  12:	00 00       	nop
  14:	61 c0       	rjmp	.+194    	; 0xd8 <__bad_interrupt>
  16:	00 00       	nop
  18:	5f c0       	rjmp	.+190    	; 0xd8 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5d c0       	rjmp	.+186    	; 0xd8 <__bad_interrupt>
  1e:	00 00       	nop
  20:	5b c0       	rjmp	.+182    	; 0xd8 <__bad_interrupt>
  22:	00 00       	nop
  24:	59 c0       	rjmp	.+178    	; 0xd8 <__bad_interrupt>
  26:	00 00       	nop
  28:	57 c0       	rjmp	.+174    	; 0xd8 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	55 c0       	rjmp	.+170    	; 0xd8 <__bad_interrupt>
  2e:	00 00       	nop
  30:	53 c0       	rjmp	.+166    	; 0xd8 <__bad_interrupt>
  32:	00 00       	nop
  34:	51 c0       	rjmp	.+162    	; 0xd8 <__bad_interrupt>
  36:	00 00       	nop
  38:	4f c0       	rjmp	.+158    	; 0xd8 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4d c0       	rjmp	.+154    	; 0xd8 <__bad_interrupt>
  3e:	00 00       	nop
  40:	4b c0       	rjmp	.+150    	; 0xd8 <__bad_interrupt>
  42:	00 00       	nop
  44:	49 c0       	rjmp	.+146    	; 0xd8 <__bad_interrupt>
  46:	00 00       	nop
  48:	47 c0       	rjmp	.+142    	; 0xd8 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	45 c0       	rjmp	.+138    	; 0xd8 <__bad_interrupt>
  4e:	00 00       	nop
  50:	43 c0       	rjmp	.+134    	; 0xd8 <__bad_interrupt>
  52:	00 00       	nop
  54:	41 c0       	rjmp	.+130    	; 0xd8 <__bad_interrupt>
  56:	00 00       	nop
  58:	3f c0       	rjmp	.+126    	; 0xd8 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3d c0       	rjmp	.+122    	; 0xd8 <__bad_interrupt>
  5e:	00 00       	nop
  60:	3b c0       	rjmp	.+118    	; 0xd8 <__bad_interrupt>
  62:	00 00       	nop
  64:	39 c0       	rjmp	.+114    	; 0xd8 <__bad_interrupt>
  66:	00 00       	nop
  68:	37 c0       	rjmp	.+110    	; 0xd8 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	35 c0       	rjmp	.+106    	; 0xd8 <__bad_interrupt>
  6e:	00 00       	nop
  70:	33 c0       	rjmp	.+102    	; 0xd8 <__bad_interrupt>
  72:	00 00       	nop
  74:	31 c0       	rjmp	.+98     	; 0xd8 <__bad_interrupt>
  76:	00 00       	nop
  78:	2f c0       	rjmp	.+94     	; 0xd8 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2d c0       	rjmp	.+90     	; 0xd8 <__bad_interrupt>
  7e:	00 00       	nop
  80:	2b c0       	rjmp	.+86     	; 0xd8 <__bad_interrupt>
  82:	00 00       	nop
  84:	29 c0       	rjmp	.+82     	; 0xd8 <__bad_interrupt>
  86:	00 00       	nop
  88:	27 c0       	rjmp	.+78     	; 0xd8 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	a3 03       	fmuls	r18, r19
  8e:	a7 03       	fmuls	r18, r23
  90:	ac 03       	fmulsu	r18, r20
  92:	b1 03       	fmuls	r19, r17
  94:	b6 03       	fmuls	r19, r22
  96:	bb 03       	fmulsu	r19, r19
  98:	c0 03       	fmuls	r20, r16
  9a:	c5 03       	fmuls	r20, r21

0000009c <__trampolines_end>:
  9c:	5a 00       	.word	0x005a	; ????

0000009e <__ctors_end>:
  9e:	11 24       	eor	r1, r1
  a0:	1f be       	out	0x3f, r1	; 63
  a2:	cf ef       	ldi	r28, 0xFF	; 255
  a4:	d0 e1       	ldi	r29, 0x10	; 16
  a6:	de bf       	out	0x3e, r29	; 62
  a8:	cd bf       	out	0x3d, r28	; 61

000000aa <__do_copy_data>:
  aa:	11 e0       	ldi	r17, 0x01	; 1
  ac:	a0 e0       	ldi	r26, 0x00	; 0
  ae:	b1 e0       	ldi	r27, 0x01	; 1
  b0:	e8 e1       	ldi	r30, 0x18	; 24
  b2:	f9 e0       	ldi	r31, 0x09	; 9
  b4:	00 e0       	ldi	r16, 0x00	; 0
  b6:	0b bf       	out	0x3b, r16	; 59
  b8:	02 c0       	rjmp	.+4      	; 0xbe <__do_copy_data+0x14>
  ba:	07 90       	elpm	r0, Z+
  bc:	0d 92       	st	X+, r0
  be:	a6 31       	cpi	r26, 0x16	; 22
  c0:	b1 07       	cpc	r27, r17
  c2:	d9 f7       	brne	.-10     	; 0xba <__do_copy_data+0x10>

000000c4 <__do_clear_bss>:
  c4:	23 e0       	ldi	r18, 0x03	; 3
  c6:	a6 e1       	ldi	r26, 0x16	; 22
  c8:	b1 e0       	ldi	r27, 0x01	; 1
  ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
  cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
  ce:	ac 32       	cpi	r26, 0x2C	; 44
  d0:	b2 07       	cpc	r27, r18
  d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
  d4:	0c d4       	rcall	.+2072   	; 0x8ee <main>
  d6:	1e c4       	rjmp	.+2108   	; 0x914 <_exit>

000000d8 <__bad_interrupt>:
  d8:	93 cf       	rjmp	.-218    	; 0x0 <__vectors>

000000da <W51_register>:
static  void           (*reset)(void) = (void *)0;

static  unsigned char            inited = FALSE;

void  W51_register(W5100_CALLBACKS  *pcallbacks)
{
  da:	fc 01       	movw	r30, r24
    select = pcallbacks->_select;
  dc:	80 81       	ld	r24, Z
  de:	91 81       	ldd	r25, Z+1	; 0x01
  e0:	90 93 1e 01 	sts	0x011E, r25
  e4:	80 93 1d 01 	sts	0x011D, r24
    xchg = pcallbacks->_xchg;
  e8:	22 81       	ldd	r18, Z+2	; 0x02
  ea:	33 81       	ldd	r19, Z+3	; 0x03
  ec:	30 93 1c 01 	sts	0x011C, r19
  f0:	20 93 1b 01 	sts	0x011B, r18
    deselect = pcallbacks->_deselect;
  f4:	44 81       	ldd	r20, Z+4	; 0x04
  f6:	55 81       	ldd	r21, Z+5	; 0x05
  f8:	50 93 1a 01 	sts	0x011A, r21
  fc:	40 93 19 01 	sts	0x0119, r20
    reset = pcallbacks->_reset;
 100:	66 81       	ldd	r22, Z+6	; 0x06
 102:	77 81       	ldd	r23, Z+7	; 0x07
 104:	70 93 18 01 	sts	0x0118, r23
 108:	60 93 17 01 	sts	0x0117, r22
    inited = FALSE;
 10c:	10 92 16 01 	sts	0x0116, r1
    if ((select) && (xchg) && (deselect))  inited = TRUE;    // these functions must be valid
 110:	89 2b       	or	r24, r25
 112:	39 f0       	breq	.+14     	; 0x122 <W51_register+0x48>
 114:	23 2b       	or	r18, r19
 116:	29 f0       	breq	.+10     	; 0x122 <W51_register+0x48>
 118:	45 2b       	or	r20, r21
 11a:	19 f0       	breq	.+6      	; 0x122 <W51_register+0x48>
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	80 93 16 01 	sts	0x0116, r24
 122:	08 95       	ret

00000124 <W51_write>:
}

void  W51_write(unsigned int  addr, unsigned char  data)
{
 124:	1f 93       	push	r17
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
    if (!inited)  return;                        // not set up, ignore request
 12a:	20 91 16 01 	lds	r18, 0x0116
 12e:	22 23       	and	r18, r18
 130:	29 f1       	breq	.+74     	; 0x17c <W51_write+0x58>
 132:	c6 2f       	mov	r28, r22
 134:	19 2f       	mov	r17, r25
 136:	d8 2f       	mov	r29, r24

    select();                                    // enable the W5100 chip
 138:	e0 91 1d 01 	lds	r30, 0x011D
 13c:	f0 91 1e 01 	lds	r31, 0x011E
 140:	09 95       	icall
    xchg(W5100_WRITE_OPCODE);                    // need to write a byte
 142:	e0 91 1b 01 	lds	r30, 0x011B
 146:	f0 91 1c 01 	lds	r31, 0x011C
 14a:	80 ef       	ldi	r24, 0xF0	; 240
 14c:	09 95       	icall
    xchg((addr & 0xff00) >> 8);                // send MSB of addr
 14e:	e0 91 1b 01 	lds	r30, 0x011B
 152:	f0 91 1c 01 	lds	r31, 0x011C
 156:	81 2f       	mov	r24, r17
 158:	09 95       	icall
    xchg(addr & 0xff);                            // send LSB
 15a:	e0 91 1b 01 	lds	r30, 0x011B
 15e:	f0 91 1c 01 	lds	r31, 0x011C
 162:	8d 2f       	mov	r24, r29
 164:	09 95       	icall
    xchg(data);                                    // send the data
 166:	e0 91 1b 01 	lds	r30, 0x011B
 16a:	f0 91 1c 01 	lds	r31, 0x011C
 16e:	8c 2f       	mov	r24, r28
 170:	09 95       	icall
    deselect();                                    // done with the chip
 172:	e0 91 19 01 	lds	r30, 0x0119
 176:	f0 91 1a 01 	lds	r31, 0x011A
 17a:	09 95       	icall
}
 17c:	df 91       	pop	r29
 17e:	cf 91       	pop	r28
 180:	1f 91       	pop	r17
 182:	08 95       	ret

00000184 <W51_read>:

unsigned char  W51_read(unsigned int  addr)
{
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
    unsigned char                val;

    if (!inited)  return  0;                    // not set up, ignore request
 188:	20 91 16 01 	lds	r18, 0x0116
 18c:	22 23       	and	r18, r18
 18e:	31 f1       	breq	.+76     	; 0x1dc <W51_read+0x58>
 190:	d9 2f       	mov	r29, r25
 192:	c8 2f       	mov	r28, r24

    select();                                    // enable the W5100 chip
 194:	e0 91 1d 01 	lds	r30, 0x011D
 198:	f0 91 1e 01 	lds	r31, 0x011E
 19c:	09 95       	icall
    xchg(W5100_READ_OPCODE);                    // need to read a byte
 19e:	e0 91 1b 01 	lds	r30, 0x011B
 1a2:	f0 91 1c 01 	lds	r31, 0x011C
 1a6:	8f e0       	ldi	r24, 0x0F	; 15
 1a8:	09 95       	icall
    xchg((addr & 0xff00) >> 8);                // send MSB of addr
 1aa:	e0 91 1b 01 	lds	r30, 0x011B
 1ae:	f0 91 1c 01 	lds	r31, 0x011C
 1b2:	8d 2f       	mov	r24, r29
 1b4:	09 95       	icall
    xchg(addr & 0xff);                            // send LSB
 1b6:	e0 91 1b 01 	lds	r30, 0x011B
 1ba:	f0 91 1c 01 	lds	r31, 0x011C
 1be:	8c 2f       	mov	r24, r28
 1c0:	09 95       	icall
    val = xchg(0x00);                            // need to send a dummy char to get response
 1c2:	e0 91 1b 01 	lds	r30, 0x011B
 1c6:	f0 91 1c 01 	lds	r31, 0x011C
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	09 95       	icall
 1ce:	c8 2f       	mov	r28, r24
    deselect();                                    // done with the chip
 1d0:	e0 91 19 01 	lds	r30, 0x0119
 1d4:	f0 91 1a 01 	lds	r31, 0x011A
 1d8:	09 95       	icall
    return  val;                                // tell her what she's won
 1da:	2c 2f       	mov	r18, r28
}
 1dc:	82 2f       	mov	r24, r18
 1de:	df 91       	pop	r29
 1e0:	cf 91       	pop	r28
 1e2:	08 95       	ret

000001e4 <W51_init>:

void  W51_init(void)
{
    if (reset)  reset();																				// if host provided a reset function, use it
 1e4:	e0 91 17 01 	lds	r30, 0x0117
 1e8:	f0 91 18 01 	lds	r31, 0x0118
 1ec:	30 97       	sbiw	r30, 0x00	; 0
 1ee:	11 f0       	breq	.+4      	; 0x1f4 <W51_init+0x10>
 1f0:	09 95       	icall
 1f2:	04 c0       	rjmp	.+8      	; 0x1fc <W51_init+0x18>
    else        W51_write(W5100_MR, W5100_MR_SOFTRST);         // otherwise, force the w5100 to soft-reset
 1f4:	60 e8       	ldi	r22, 0x80	; 128
 1f6:	80 e0       	ldi	r24, 0x00	; 0
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	94 df       	rcall	.-216    	; 0x124 <W51_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1fc:	8f e1       	ldi	r24, 0x1F	; 31
 1fe:	9e e4       	ldi	r25, 0x4E	; 78
 200:	01 97       	sbiw	r24, 0x01	; 1
 202:	f1 f7       	brne	.-4      	; 0x200 <W51_init+0x1c>
 204:	00 c0       	rjmp	.+0      	; 0x206 <W51_init+0x22>
 206:	00 00       	nop
 208:	08 95       	ret

0000020a <W51_config>:
    _delay_ms(5);
}

unsigned char  W51_config(W5100_CFG  *pcfg)
{
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
    if (pcfg == 0)  return  W5100_FAIL;
 20e:	00 97       	sbiw	r24, 0x00	; 0
 210:	09 f4       	brne	.+2      	; 0x214 <W51_config+0xa>
 212:	79 c0       	rjmp	.+242    	; 0x306 <W51_config+0xfc>
 214:	ec 01       	movw	r28, r24

    W51_write(W5100_GAR + 0, pcfg->gtw_addr[0]);    // set up the gateway address
 216:	6e 85       	ldd	r22, Y+14	; 0x0e
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	83 df       	rcall	.-250    	; 0x124 <W51_write>
    W51_write(W5100_GAR + 1, pcfg->gtw_addr[1]);
 21e:	6f 85       	ldd	r22, Y+15	; 0x0f
 220:	82 e0       	ldi	r24, 0x02	; 2
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	7f df       	rcall	.-258    	; 0x124 <W51_write>
    W51_write(W5100_GAR + 2, pcfg->gtw_addr[2]);
 226:	68 89       	ldd	r22, Y+16	; 0x10
 228:	83 e0       	ldi	r24, 0x03	; 3
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	7b df       	rcall	.-266    	; 0x124 <W51_write>
    W51_write(W5100_GAR + 3, pcfg->gtw_addr[3]);
 22e:	69 89       	ldd	r22, Y+17	; 0x11
 230:	84 e0       	ldi	r24, 0x04	; 4
 232:	90 e0       	ldi	r25, 0x00	; 0
 234:	77 df       	rcall	.-274    	; 0x124 <W51_write>
 236:	8f e9       	ldi	r24, 0x9F	; 159
 238:	9f e0       	ldi	r25, 0x0F	; 15
 23a:	01 97       	sbiw	r24, 0x01	; 1
 23c:	f1 f7       	brne	.-4      	; 0x23a <W51_config+0x30>
 23e:	00 c0       	rjmp	.+0      	; 0x240 <W51_config+0x36>
 240:	00 00       	nop
    _delay_ms(1);

    W51_write(W5100_SHAR + 0, pcfg->mac_addr[0]);    // set up the MAC address
 242:	68 81       	ld	r22, Y
 244:	89 e0       	ldi	r24, 0x09	; 9
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	6d df       	rcall	.-294    	; 0x124 <W51_write>
    W51_write(W5100_SHAR + 1, pcfg->mac_addr[1]);
 24a:	69 81       	ldd	r22, Y+1	; 0x01
 24c:	8a e0       	ldi	r24, 0x0A	; 10
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	69 df       	rcall	.-302    	; 0x124 <W51_write>
    W51_write(W5100_SHAR + 2, pcfg->mac_addr[2]);
 252:	6a 81       	ldd	r22, Y+2	; 0x02
 254:	8b e0       	ldi	r24, 0x0B	; 11
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	65 df       	rcall	.-310    	; 0x124 <W51_write>
    W51_write(W5100_SHAR + 3, pcfg->mac_addr[3]);
 25a:	6b 81       	ldd	r22, Y+3	; 0x03
 25c:	8c e0       	ldi	r24, 0x0C	; 12
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	61 df       	rcall	.-318    	; 0x124 <W51_write>
    W51_write(W5100_SHAR + 4, pcfg->mac_addr[4]);
 262:	6c 81       	ldd	r22, Y+4	; 0x04
 264:	8d e0       	ldi	r24, 0x0D	; 13
 266:	90 e0       	ldi	r25, 0x00	; 0
 268:	5d df       	rcall	.-326    	; 0x124 <W51_write>
    W51_write(W5100_SHAR + 5, pcfg->mac_addr[5]);
 26a:	6d 81       	ldd	r22, Y+5	; 0x05
 26c:	8e e0       	ldi	r24, 0x0E	; 14
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	59 df       	rcall	.-334    	; 0x124 <W51_write>
 272:	8f e9       	ldi	r24, 0x9F	; 159
 274:	9f e0       	ldi	r25, 0x0F	; 15
 276:	01 97       	sbiw	r24, 0x01	; 1
 278:	f1 f7       	brne	.-4      	; 0x276 <W51_config+0x6c>
 27a:	00 c0       	rjmp	.+0      	; 0x27c <W51_config+0x72>
 27c:	00 00       	nop
    _delay_ms(1);
		
    W51_write(W5100_SUBR + 0, pcfg->sub_mask[0]);    // set up the subnet mask
 27e:	6a 85       	ldd	r22, Y+10	; 0x0a
 280:	85 e0       	ldi	r24, 0x05	; 5
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	4f df       	rcall	.-354    	; 0x124 <W51_write>
    W51_write(W5100_SUBR + 1, pcfg->sub_mask[1]);
 286:	6b 85       	ldd	r22, Y+11	; 0x0b
 288:	86 e0       	ldi	r24, 0x06	; 6
 28a:	90 e0       	ldi	r25, 0x00	; 0
 28c:	4b df       	rcall	.-362    	; 0x124 <W51_write>
    W51_write(W5100_SUBR + 2, pcfg->sub_mask[2]);
 28e:	6c 85       	ldd	r22, Y+12	; 0x0c
 290:	87 e0       	ldi	r24, 0x07	; 7
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	47 df       	rcall	.-370    	; 0x124 <W51_write>
    W51_write(W5100_SUBR + 3, pcfg->sub_mask[3]);
 296:	6d 85       	ldd	r22, Y+13	; 0x0d
 298:	88 e0       	ldi	r24, 0x08	; 8
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	43 df       	rcall	.-378    	; 0x124 <W51_write>
 29e:	8f e9       	ldi	r24, 0x9F	; 159
 2a0:	9f e0       	ldi	r25, 0x0F	; 15
 2a2:	01 97       	sbiw	r24, 0x01	; 1
 2a4:	f1 f7       	brne	.-4      	; 0x2a2 <W51_config+0x98>
 2a6:	00 c0       	rjmp	.+0      	; 0x2a8 <W51_config+0x9e>
 2a8:	00 00       	nop
    _delay_ms(1);

    W51_write(W5100_SIPR + 0, pcfg->ip_addr[0]);    // set up the source IP address
 2aa:	6e 81       	ldd	r22, Y+6	; 0x06
 2ac:	8f e0       	ldi	r24, 0x0F	; 15
 2ae:	90 e0       	ldi	r25, 0x00	; 0
 2b0:	39 df       	rcall	.-398    	; 0x124 <W51_write>
    W51_write(W5100_SIPR + 1, pcfg->ip_addr[1]);
 2b2:	6f 81       	ldd	r22, Y+7	; 0x07
 2b4:	80 e1       	ldi	r24, 0x10	; 16
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	35 df       	rcall	.-406    	; 0x124 <W51_write>
    W51_write(W5100_SIPR + 2, pcfg->ip_addr[2]);
 2ba:	68 85       	ldd	r22, Y+8	; 0x08
 2bc:	81 e1       	ldi	r24, 0x11	; 17
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	31 df       	rcall	.-414    	; 0x124 <W51_write>
    W51_write(W5100_SIPR + 3, pcfg->ip_addr[3]);
 2c2:	69 85       	ldd	r22, Y+9	; 0x09
 2c4:	82 e1       	ldi	r24, 0x12	; 18
 2c6:	90 e0       	ldi	r25, 0x00	; 0
 2c8:	2d df       	rcall	.-422    	; 0x124 <W51_write>
 2ca:	8f e9       	ldi	r24, 0x9F	; 159
 2cc:	9f e0       	ldi	r25, 0x0F	; 15
 2ce:	01 97       	sbiw	r24, 0x01	; 1
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <W51_config+0xc4>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <W51_config+0xca>
 2d4:	00 00       	nop
    _delay_ms(1);

		W51_write(W5100_RTR, 0x0F);
 2d6:	6f e0       	ldi	r22, 0x0F	; 15
 2d8:	87 e1       	ldi	r24, 0x17	; 23
 2da:	90 e0       	ldi	r25, 0x00	; 0
 2dc:	23 df       	rcall	.-442    	; 0x124 <W51_write>
		W51_write(W5100_RTR + 1, 0xA0);
 2de:	60 ea       	ldi	r22, 0xA0	; 160
 2e0:	88 e1       	ldi	r24, 0x18	; 24
 2e2:	90 e0       	ldi	r25, 0x00	; 0
 2e4:	1f df       	rcall	.-450    	; 0x124 <W51_write>
 2e6:	8f e9       	ldi	r24, 0x9F	; 159
 2e8:	9f e0       	ldi	r25, 0x0F	; 15
 2ea:	01 97       	sbiw	r24, 0x01	; 1
 2ec:	f1 f7       	brne	.-4      	; 0x2ea <W51_config+0xe0>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <W51_config+0xe6>
 2f0:	00 00       	nop
		_delay_ms(1);
		
    W51_write(W5100_RMSR, 0b01010101);              // 2K per socket
 2f2:	65 e5       	ldi	r22, 0x55	; 85
 2f4:	8a e1       	ldi	r24, 0x1A	; 26
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	15 df       	rcall	.-470    	; 0x124 <W51_write>
    W51_write(W5100_TMSR, 0b01010101);
 2fa:	65 e5       	ldi	r22, 0x55	; 85
 2fc:	8b e1       	ldi	r24, 0x1B	; 27
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	11 df       	rcall	.-478    	; 0x124 <W51_write>
		
    return  W5100_OK;
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	01 c0       	rjmp	.+2      	; 0x308 <W51_config+0xfe>
    _delay_ms(5);
}

unsigned char  W51_config(W5100_CFG  *pcfg)
{
    if (pcfg == 0)  return  W5100_FAIL;
 306:	8f ef       	ldi	r24, 0xFF	; 255
		
    W51_write(W5100_RMSR, 0b01010101);              // 2K per socket
    W51_write(W5100_TMSR, 0b01010101);
		
    return  W5100_OK;
 308:	df 91       	pop	r29
 30a:	cf 91       	pop	r28
 30c:	08 95       	ret

0000030e <selectEthernet>:
	/*
	*  Simple wrapper function for selecting the W5100 device.  This function
	*  allows the library code to invoke a target-specific function for enabling
	*  the W5100 chip.
	*/
	W51_ENABLE;
 30e:	c0 98       	cbi	0x18, 0	; 24
 310:	08 95       	ret

00000312 <deselectEthernet>:
	*  Simple wrapper function for de-selecting the W5100 device.  This function
	*  allows the library code to invoke a target-specific function for disabling
	*  the W5100 chip.
	*/
	
	W51_DISABLE;
 312:	c0 9a       	sbi	0x18, 0	; 24
 314:	08 95       	ret

00000316 <xchgData>:
unsigned char xchgData(unsigned char  val)
{
	/*
	*  my_xchg      callback function; exchanges a byte with W5100 chip
	*/
	SPDR = val;
 316:	8f b9       	out	0x0f, r24	; 15
	while  (!(SPSR & (1<<SPIF)))  ;
 318:	77 9b       	sbis	0x0e, 7	; 14
 31a:	fe cf       	rjmp	.-4      	; 0x318 <xchgData+0x2>
	return  SPDR;
 31c:	8f b1       	in	r24, 0x0f	; 15
}
 31e:	08 95       	ret

00000320 <resetEthernet>:
void resetEthernet(void)
{
	/*
	*  my_reset      callback function; force a hardware reset of the W5100 device
	*/
	SPI_DDR |= (1<<RESET_BIT);
 320:	bc 9a       	sbi	0x17, 4	; 23
	SPI_PORT |= (1<<RESET_BIT);
 322:	c4 9a       	sbi	0x18, 4	; 24
	
	SPI_PORT &= ~(1<<RESET_BIT);																		//  pull the line low
 324:	c4 98       	cbi	0x18, 4	; 24
 326:	8f e3       	ldi	r24, 0x3F	; 63
 328:	9c e9       	ldi	r25, 0x9C	; 156
 32a:	01 97       	sbiw	r24, 0x01	; 1
 32c:	f1 f7       	brne	.-4      	; 0x32a <resetEthernet+0xa>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <resetEthernet+0x10>
 330:	00 00       	nop
	_delay_ms(10);																									//  let the device reset
	SPI_PORT |= (1<<RESET_BIT);																			//  done with reset, pull the line high
 332:	c4 9a       	sbi	0x18, 4	; 24
 334:	9f ef       	ldi	r25, 0xFF	; 255
 336:	21 ee       	ldi	r18, 0xE1	; 225
 338:	84 e0       	ldi	r24, 0x04	; 4
 33a:	91 50       	subi	r25, 0x01	; 1
 33c:	20 40       	sbci	r18, 0x00	; 0
 33e:	80 40       	sbci	r24, 0x00	; 0
 340:	e1 f7       	brne	.-8      	; 0x33a <resetEthernet+0x1a>
 342:	00 c0       	rjmp	.+0      	; 0x344 <resetEthernet+0x24>
 344:	00 00       	nop
 346:	08 95       	ret

00000348 <Close>:

	return  retval;
}

void  Close(unsigned char  sock)
{
 348:	cf 93       	push	r28
 34a:	df 93       	push	r29
	unsigned int			sockaddr;
	
	if (sock > W5100_NUM_SOCKETS)  {		
 34c:	83 30       	cpi	r24, 0x03	; 3
 34e:	68 f4       	brcc	.+26     	; 0x36a <Close+0x22>
		return;																															// if illegal socket number, ignore request
	}
	sockaddr = W5100_SKT_BASE(sock);																			// calc base addr for this socket
 350:	c8 2f       	mov	r28, r24
 352:	d0 e0       	ldi	r29, 0x00	; 0
 354:	dc 2f       	mov	r29, r28
 356:	cc 27       	eor	r28, r28

	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_CLOSE);							// tell chip to close the socket
 358:	cf 5f       	subi	r28, 0xFF	; 255
 35a:	db 4f       	sbci	r29, 0xFB	; 251
 35c:	60 e1       	ldi	r22, 0x10	; 16
 35e:	ce 01       	movw	r24, r28
 360:	e1 de       	rcall	.-574    	; 0x124 <W51_write>
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;													// loop until socket is closed (blocks!!)
 362:	ce 01       	movw	r24, r28
 364:	0f df       	rcall	.-482    	; 0x184 <W51_read>
 366:	81 11       	cpse	r24, r1
 368:	fc cf       	rjmp	.-8      	; 0x362 <Close+0x1a>
}
 36a:	df 91       	pop	r29
 36c:	cf 91       	pop	r28
 36e:	08 95       	ret

00000370 <Connect>:
	_delay_ms(1000);
	NET_Init();
}

unsigned char Connect(unsigned char sock, unsigned char ip[4] ,unsigned char eth_protocol, unsigned int tcp_port)
{
 370:	af 92       	push	r10
 372:	bf 92       	push	r11
 374:	cf 92       	push	r12
 376:	df 92       	push	r13
 378:	ef 92       	push	r14
 37a:	ff 92       	push	r15
 37c:	0f 93       	push	r16
 37e:	1f 93       	push	r17
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	c8 2f       	mov	r28, r24
 386:	7b 01       	movw	r14, r22
 388:	a4 2e       	mov	r10, r20
 38a:	d2 2f       	mov	r29, r18
 38c:	b3 2e       	mov	r11, r19
	unsigned char			retval;
	unsigned int			sockaddr;
	
	retval = W5100_FAIL;	
																									// assume this doesn't work
	if (sock >= W5100_NUM_SOCKETS)  {
 38e:	82 30       	cpi	r24, 0x02	; 2
 390:	08 f0       	brcs	.+2      	; 0x394 <Connect+0x24>
 392:	48 c0       	rjmp	.+144    	; 0x424 <Connect+0xb4>
		return retval;																											// illegal socket value is bad!
	}
	
	sockaddr =  W5100_SKT_BASE(sock);																			// calc base addr for this socket
 394:	08 2f       	mov	r16, r24
 396:	10 e0       	ldi	r17, 0x00	; 0
 398:	0c 5f       	subi	r16, 0xFC	; 252
 39a:	1f 4f       	sbci	r17, 0xFF	; 255
 39c:	10 2f       	mov	r17, r16
 39e:	00 27       	eor	r16, r16

	if (W51_read(sockaddr+W5100_SR_OFFSET) == W5100_SKT_SR_CLOSED)				// Make sure we close the socket first
 3a0:	68 01       	movw	r12, r16
 3a2:	83 e0       	ldi	r24, 0x03	; 3
 3a4:	c8 0e       	add	r12, r24
 3a6:	d1 1c       	adc	r13, r1
 3a8:	c6 01       	movw	r24, r12
 3aa:	ec de       	rcall	.-552    	; 0x184 <W51_read>
 3ac:	81 11       	cpse	r24, r1
 3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <Connect+0x44>
	{
		Close(sock);
 3b0:	8c 2f       	mov	r24, r28
 3b2:	ca df       	rcall	.-108    	; 0x348 <Close>
	}

	// W51_write(sockaddr+W5100_MR_OFFSET ,0b01000000);											// Enable Mac Filtering
	W51_write(sockaddr+W5100_MR_OFFSET ,eth_protocol);										// set protocol for this socket
 3b4:	6a 2d       	mov	r22, r10
 3b6:	c8 01       	movw	r24, r16
 3b8:	b5 de       	rcall	.-662    	; 0x124 <W51_write>
	
	W51_write(sockaddr+W5100_DIPR_OFFSET,     ip[0]);												// set ip for server
 3ba:	f7 01       	movw	r30, r14
 3bc:	60 81       	ld	r22, Z
 3be:	c8 01       	movw	r24, r16
 3c0:	0c 96       	adiw	r24, 0x0c	; 12
 3c2:	b0 de       	rcall	.-672    	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_DIPR_OFFSET + 1, ip[1]);		// set ip for server
 3c4:	f7 01       	movw	r30, r14
 3c6:	61 81       	ldd	r22, Z+1	; 0x01
 3c8:	c8 01       	movw	r24, r16
 3ca:	0d 96       	adiw	r24, 0x0d	; 13
 3cc:	ab de       	rcall	.-682    	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_DIPR_OFFSET + 2, ip[2]);		// set ip for server
 3ce:	f7 01       	movw	r30, r14
 3d0:	62 81       	ldd	r22, Z+2	; 0x02
 3d2:	c8 01       	movw	r24, r16
 3d4:	0e 96       	adiw	r24, 0x0e	; 14
 3d6:	a6 de       	rcall	.-692    	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_DIPR_OFFSET + 3, ip[3]);		// set ip for server
 3d8:	f7 01       	movw	r30, r14
 3da:	63 81       	ldd	r22, Z+3	; 0x03
 3dc:	c8 01       	movw	r24, r16
 3de:	0f 96       	adiw	r24, 0x0f	; 15
 3e0:	a1 de       	rcall	.-702    	; 0x124 <W51_write>
	
	W51_write(sockaddr+W5100_DPORT_OFFSET, ((tcp_port & 0xFF00) >> 8 ));		// set port for server (MSB)
 3e2:	6b 2d       	mov	r22, r11
 3e4:	c8 01       	movw	r24, r16
 3e6:	40 96       	adiw	r24, 0x10	; 16
 3e8:	9d de       	rcall	.-710    	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_DPORT_OFFSET + 1, (tcp_port & 0x00FF));				// set port for server (LSB)
 3ea:	6d 2f       	mov	r22, r29
 3ec:	c8 01       	movw	r24, r16
 3ee:	41 96       	adiw	r24, 0x11	; 17
 3f0:	99 de       	rcall	.-718    	; 0x124 <W51_write>
	
	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_OPEN);	              // open the socket
 3f2:	0f 5f       	subi	r16, 0xFF	; 255
 3f4:	1f 4f       	sbci	r17, 0xFF	; 255
 3f6:	61 e0       	ldi	r22, 0x01	; 1
 3f8:	c8 01       	movw	r24, r16
 3fa:	94 de       	rcall	.-728    	; 0x124 <W51_write>
	
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;													// loop until device reports socket is open (blocks!!)
 3fc:	c8 01       	movw	r24, r16
 3fe:	c2 de       	rcall	.-636    	; 0x184 <W51_read>
 400:	81 11       	cpse	r24, r1
 402:	fc cf       	rjmp	.-8      	; 0x3fc <Connect+0x8c>

	if (W51_read(sockaddr+W5100_SR_OFFSET) == W5100_SKT_SR_INIT){
 404:	c6 01       	movw	r24, r12
 406:	be de       	rcall	.-644    	; 0x184 <W51_read>
 408:	83 31       	cpi	r24, 0x13	; 19
 40a:	41 f4       	brne	.+16     	; 0x41c <Connect+0xac>
		
		W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_CONNECT);	       // connect to server
 40c:	64 e0       	ldi	r22, 0x04	; 4
 40e:	c8 01       	movw	r24, r16
 410:	89 de       	rcall	.-750    	; 0x124 <W51_write>
		while (W51_read(sockaddr+W5100_CR_OFFSET))  ;											// loop until device reports socket is open (blocks!!)
 412:	c8 01       	movw	r24, r16
 414:	b7 de       	rcall	.-658    	; 0x184 <W51_read>
 416:	81 11       	cpse	r24, r1
 418:	fc cf       	rjmp	.-8      	; 0x412 <Connect+0xa2>
 41a:	05 c0       	rjmp	.+10     	; 0x426 <Connect+0xb6>
		
		retval = sock;																										// if success, return socket number
	}
	else  Close(sock);																							// if failed, close socket immediately
 41c:	8c 2f       	mov	r24, r28
 41e:	94 df       	rcall	.-216    	; 0x348 <Close>
unsigned char Connect(unsigned char sock, unsigned char ip[4] ,unsigned char eth_protocol, unsigned int tcp_port)
{
	unsigned char			retval;
	unsigned int			sockaddr;
	
	retval = W5100_FAIL;	
 420:	cf ef       	ldi	r28, 0xFF	; 255
 422:	01 c0       	rjmp	.+2      	; 0x426 <Connect+0xb6>
																									// assume this doesn't work
	if (sock >= W5100_NUM_SOCKETS)  {
		return retval;																											// illegal socket value is bad!
 424:	cf ef       	ldi	r28, 0xFF	; 255
		retval = sock;																										// if success, return socket number
	}
	else  Close(sock);																							// if failed, close socket immediately

	return  retval;
}
 426:	8c 2f       	mov	r24, r28
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	1f 91       	pop	r17
 42e:	0f 91       	pop	r16
 430:	ff 90       	pop	r15
 432:	ef 90       	pop	r14
 434:	df 90       	pop	r13
 436:	cf 90       	pop	r12
 438:	bf 90       	pop	r11
 43a:	af 90       	pop	r10
 43c:	08 95       	ret

0000043e <Disconnect>:
	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_CLOSE);							// tell chip to close the socket
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;													// loop until socket is closed (blocks!!)
}

void  Disconnect(unsigned char  sock)
{
 43e:	cf 93       	push	r28
 440:	df 93       	push	r29
	unsigned int			sockaddr;
	
	if (sock > W5100_NUM_SOCKETS)  {
 442:	83 30       	cpi	r24, 0x03	; 3
 444:	68 f4       	brcc	.+26     	; 0x460 <Disconnect+0x22>
		return;																// if illegal socket number, ignore request
	}
	sockaddr = W5100_SKT_BASE(sock);																			// calc base addr for this socket
 446:	c8 2f       	mov	r28, r24
 448:	d0 e0       	ldi	r29, 0x00	; 0
 44a:	dc 2f       	mov	r29, r28
 44c:	cc 27       	eor	r28, r28

	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_DISCON);							// disconnect the socket
 44e:	cf 5f       	subi	r28, 0xFF	; 255
 450:	db 4f       	sbci	r29, 0xFB	; 251
 452:	68 e0       	ldi	r22, 0x08	; 8
 454:	ce 01       	movw	r24, r28
 456:	66 de       	rcall	.-820    	; 0x124 <W51_write>
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;													// loop until socket is closed (blocks!!)
 458:	ce 01       	movw	r24, r28
 45a:	94 de       	rcall	.-728    	; 0x184 <W51_read>
 45c:	81 11       	cpse	r24, r1
 45e:	fc cf       	rjmp	.-8      	; 0x458 <Disconnect+0x1a>
}
 460:	df 91       	pop	r29
 462:	cf 91       	pop	r28
 464:	08 95       	ret

00000466 <Send>:

unsigned char Send(unsigned char  sock, const unsigned char  *buf, unsigned int  buflen)
{
 466:	2f 92       	push	r2
 468:	3f 92       	push	r3
 46a:	4f 92       	push	r4
 46c:	5f 92       	push	r5
 46e:	6f 92       	push	r6
 470:	7f 92       	push	r7
 472:	8f 92       	push	r8
 474:	9f 92       	push	r9
 476:	af 92       	push	r10
 478:	bf 92       	push	r11
 47a:	cf 92       	push	r12
 47c:	df 92       	push	r13
 47e:	ef 92       	push	r14
 480:	ff 92       	push	r15
 482:	0f 93       	push	r16
 484:	1f 93       	push	r17
 486:	cf 93       	push	r28
 488:	df 93       	push	r29
 48a:	78 2e       	mov	r7, r24
 48c:	7b 01       	movw	r14, r22
 48e:	8a 01       	movw	r16, r20
	unsigned int					realaddr;
	unsigned int					txsize;
	unsigned int					timeout;
	unsigned int					sockaddr;

	if (buflen == 0 || sock >= W5100_NUM_SOCKETS)  return  W5100_FAIL;		// ignore illegal requests
 490:	45 2b       	or	r20, r21
 492:	09 f4       	brne	.+2      	; 0x496 <Send+0x30>
 494:	60 c0       	rjmp	.+192    	; 0x556 <Send+0xf0>
 496:	81 e0       	ldi	r24, 0x01	; 1
 498:	87 15       	cp	r24, r7
 49a:	08 f4       	brcc	.+2      	; 0x49e <Send+0x38>
 49c:	5e c0       	rjmp	.+188    	; 0x55a <Send+0xf4>
	sockaddr = W5100_SKT_BASE(sock);																			// calc base addr for this socket
 49e:	27 2c       	mov	r2, r7
 4a0:	31 2c       	mov	r3, r1
 4a2:	21 01       	movw	r4, r2
 4a4:	94 e0       	ldi	r25, 0x04	; 4
 4a6:	49 0e       	add	r4, r25
 4a8:	51 1c       	adc	r5, r1
 4aa:	54 2c       	mov	r5, r4
 4ac:	44 24       	eor	r4, r4
	// Make sure the TX Free Size Register is available
	txsize = W51_read(sockaddr+W5100_TX_FSR_OFFSET);											// make sure the TX free-size reg is available
 4ae:	52 01       	movw	r10, r4
 4b0:	e0 e2       	ldi	r30, 0x20	; 32
 4b2:	ae 0e       	add	r10, r30
 4b4:	b1 1c       	adc	r11, r1
 4b6:	c5 01       	movw	r24, r10
 4b8:	65 de       	rcall	.-822    	; 0x184 <W51_read>
 4ba:	c8 2f       	mov	r28, r24
 4bc:	d0 e0       	ldi	r29, 0x00	; 0
	txsize = (((txsize & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_FSR_OFFSET + 1));
 4be:	dc 2f       	mov	r29, r28
 4c0:	cc 27       	eor	r28, r28
 4c2:	62 01       	movw	r12, r4
 4c4:	f1 e2       	ldi	r31, 0x21	; 33
 4c6:	cf 0e       	add	r12, r31
 4c8:	d1 1c       	adc	r13, r1
 4ca:	c6 01       	movw	r24, r12
 4cc:	5b de       	rcall	.-842    	; 0x184 <W51_read>
 4ce:	c8 0f       	add	r28, r24
 4d0:	d1 1d       	adc	r29, r1

	timeout = 0;
	while (txsize < buflen)
 4d2:	c0 17       	cp	r28, r16
 4d4:	d1 07       	cpc	r29, r17
 4d6:	08 f4       	brcc	.+2      	; 0x4da <Send+0x74>
 4d8:	5f c0       	rjmp	.+190    	; 0x598 <Send+0x132>
 4da:	41 c0       	rjmp	.+130    	; 0x55e <Send+0xf8>
 4dc:	8f e9       	ldi	r24, 0x9F	; 159
 4de:	9f e0       	ldi	r25, 0x0F	; 15
 4e0:	01 97       	sbiw	r24, 0x01	; 1
 4e2:	f1 f7       	brne	.-4      	; 0x4e0 <Send+0x7a>
 4e4:	00 c0       	rjmp	.+0      	; 0x4e6 <Send+0x80>
 4e6:	00 00       	nop
	{
		_delay_ms(1);

		txsize = W51_read(sockaddr+W5100_TX_FSR_OFFSET);										// make sure the TX free-size reg is available
 4e8:	c5 01       	movw	r24, r10
 4ea:	4c de       	rcall	.-872    	; 0x184 <W51_read>
 4ec:	c8 2f       	mov	r28, r24
 4ee:	d0 e0       	ldi	r29, 0x00	; 0
		txsize = (((txsize & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_FSR_OFFSET + 1));
 4f0:	dc 2f       	mov	r29, r28
 4f2:	cc 27       	eor	r28, r28
 4f4:	c6 01       	movw	r24, r12
 4f6:	46 de       	rcall	.-884    	; 0x184 <W51_read>
 4f8:	c8 0f       	add	r28, r24
 4fa:	d1 1d       	adc	r29, r1
 4fc:	91 e0       	ldi	r25, 0x01	; 1
 4fe:	89 1a       	sub	r8, r25
 500:	91 08       	sbc	r9, r1

		if (timeout++ > 2048) 																							// if max delay has passed...
 502:	21 f4       	brne	.+8      	; 0x50c <Send+0xa6>
		{
			#ifdef DBG
			printf("Send() - Timeout expired\n");
			#endif
			
			Disconnect(sock);																						// can't connect, close it down
 504:	87 2d       	mov	r24, r7
 506:	9b df       	rcall	.-202    	; 0x43e <Disconnect>
			return  W5100_FAIL;																								// show failure
 508:	8f ef       	ldi	r24, 0xFF	; 255
 50a:	5c c0       	rjmp	.+184    	; 0x5c4 <Send+0x15e>
	// Make sure the TX Free Size Register is available
	txsize = W51_read(sockaddr+W5100_TX_FSR_OFFSET);											// make sure the TX free-size reg is available
	txsize = (((txsize & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_FSR_OFFSET + 1));

	timeout = 0;
	while (txsize < buflen)
 50c:	c0 17       	cp	r28, r16
 50e:	d1 07       	cpc	r29, r17
 510:	28 f3       	brcs	.-54     	; 0x4dc <Send+0x76>
 512:	25 c0       	rjmp	.+74     	; 0x55e <Send+0xf8>
	ptr = W51_read(sockaddr+W5100_TX_WR_OFFSET);
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_WR_OFFSET + 1));

	while (buflen)
	{
		buflen--;
 514:	21 97       	sbiw	r28, 0x01	; 1
		realaddr = (W5100_TXBUFADDR + (0x0800 * sock)) + (offaddr & W5100_TX_BUF_MASK);        // calc W5100 physical buffer addr for this socket
 516:	c6 01       	movw	r24, r12
 518:	97 70       	andi	r25, 0x07	; 7

		W51_write(realaddr, *buf);																				// send a byte of application data to TX buffer
 51a:	f7 01       	movw	r30, r14
 51c:	61 91       	ld	r22, Z+
 51e:	7f 01       	movw	r14, r30
 520:	82 0d       	add	r24, r2
 522:	93 1d       	adc	r25, r3
 524:	ff dd       	rcall	.-1026   	; 0x124 <W51_write>
		offaddr++;																												// next TX buffer addr
 526:	ff ef       	ldi	r31, 0xFF	; 255
 528:	cf 1a       	sub	r12, r31
 52a:	df 0a       	sbc	r13, r31

	// Read the TX Write Pointer
	ptr = W51_read(sockaddr+W5100_TX_WR_OFFSET);
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_WR_OFFSET + 1));

	while (buflen)
 52c:	20 97       	sbiw	r28, 0x00	; 0
 52e:	91 f7       	brne	.-28     	; 0x514 <Send+0xae>
 530:	06 0d       	add	r16, r6
 532:	17 1d       	adc	r17, r7
		W51_write(realaddr, *buf);																				// send a byte of application data to TX buffer
		offaddr++;																												// next TX buffer addr
		buf++;																														// next input buffer addr
	}

	W51_write(sockaddr+W5100_TX_WR_OFFSET, (offaddr & 0xFF00) >> 8);		// send MSB of new write-pointer addr
 534:	61 2f       	mov	r22, r17
 536:	c5 01       	movw	r24, r10
 538:	f5 dd       	rcall	.-1046   	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_TX_WR_OFFSET + 1, (offaddr & 0x00FF));			// send LSB
 53a:	60 2f       	mov	r22, r16
 53c:	c4 01       	movw	r24, r8
 53e:	f2 dd       	rcall	.-1052   	; 0x124 <W51_write>

	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_SEND);							// start the send on its way
 540:	8f ef       	ldi	r24, 0xFF	; 255
 542:	48 1a       	sub	r4, r24
 544:	58 0a       	sbc	r5, r24
 546:	60 e2       	ldi	r22, 0x20	; 32
 548:	c2 01       	movw	r24, r4
 54a:	ec dd       	rcall	.-1064   	; 0x124 <W51_write>
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;												// loop until socket starts the send (blocks!!)
 54c:	c2 01       	movw	r24, r4
 54e:	1a de       	rcall	.-972    	; 0x184 <W51_read>
 550:	81 11       	cpse	r24, r1
 552:	fc cf       	rjmp	.-8      	; 0x54c <Send+0xe6>
 554:	37 c0       	rjmp	.+110    	; 0x5c4 <Send+0x15e>
	unsigned int					realaddr;
	unsigned int					txsize;
	unsigned int					timeout;
	unsigned int					sockaddr;

	if (buflen == 0 || sock >= W5100_NUM_SOCKETS)  return  W5100_FAIL;		// ignore illegal requests
 556:	8f ef       	ldi	r24, 0xFF	; 255
 558:	35 c0       	rjmp	.+106    	; 0x5c4 <Send+0x15e>
 55a:	8f ef       	ldi	r24, 0xFF	; 255
 55c:	33 c0       	rjmp	.+102    	; 0x5c4 <Send+0x15e>
			return  W5100_FAIL;																								// show failure
		}
	}

	// Read the TX Write Pointer
	ptr = W51_read(sockaddr+W5100_TX_WR_OFFSET);
 55e:	52 01       	movw	r10, r4
 560:	94 e2       	ldi	r25, 0x24	; 36
 562:	a9 0e       	add	r10, r25
 564:	b1 1c       	adc	r11, r1
 566:	c5 01       	movw	r24, r10
 568:	0d de       	rcall	.-998    	; 0x184 <W51_read>
 56a:	68 2e       	mov	r6, r24
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_WR_OFFSET + 1));
 56c:	42 01       	movw	r8, r4
 56e:	e5 e2       	ldi	r30, 0x25	; 37
 570:	8e 0e       	add	r8, r30
 572:	91 1c       	adc	r9, r1
 574:	c4 01       	movw	r24, r8
 576:	06 de       	rcall	.-1012   	; 0x184 <W51_read>
			return  W5100_FAIL;																								// show failure
		}
	}

	// Read the TX Write Pointer
	ptr = W51_read(sockaddr+W5100_TX_WR_OFFSET);
 578:	71 2c       	mov	r7, r1
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_WR_OFFSET + 1));
 57a:	76 2c       	mov	r7, r6
 57c:	66 24       	eor	r6, r6
 57e:	68 0e       	add	r6, r24
 580:	71 1c       	adc	r7, r1

	while (buflen)
	{
		buflen--;
		realaddr = (W5100_TXBUFADDR + (0x0800 * sock)) + (offaddr & W5100_TX_BUF_MASK);        // calc W5100 physical buffer addr for this socket
 582:	f8 e0       	ldi	r31, 0x08	; 8
 584:	2f 0e       	add	r2, r31
 586:	31 1c       	adc	r3, r1
 588:	32 2c       	mov	r3, r2
 58a:	22 24       	eor	r2, r2
 58c:	33 0c       	add	r3, r3
 58e:	33 0c       	add	r3, r3
 590:	33 0c       	add	r3, r3
		}
	}

	// Read the TX Write Pointer
	ptr = W51_read(sockaddr+W5100_TX_WR_OFFSET);
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_WR_OFFSET + 1));
 592:	63 01       	movw	r12, r6

	while (buflen)
	{
		buflen--;
		realaddr = (W5100_TXBUFADDR + (0x0800 * sock)) + (offaddr & W5100_TX_BUF_MASK);        // calc W5100 physical buffer addr for this socket
 594:	e8 01       	movw	r28, r16
 596:	be cf       	rjmp	.-132    	; 0x514 <Send+0xae>
 598:	8f e9       	ldi	r24, 0x9F	; 159
 59a:	9f e0       	ldi	r25, 0x0F	; 15
 59c:	01 97       	sbiw	r24, 0x01	; 1
 59e:	f1 f7       	brne	.-4      	; 0x59c <Send+0x136>
 5a0:	00 c0       	rjmp	.+0      	; 0x5a2 <Send+0x13c>
 5a2:	00 00       	nop
	timeout = 0;
	while (txsize < buflen)
	{
		_delay_ms(1);

		txsize = W51_read(sockaddr+W5100_TX_FSR_OFFSET);										// make sure the TX free-size reg is available
 5a4:	c5 01       	movw	r24, r10
 5a6:	ee dd       	rcall	.-1060   	; 0x184 <W51_read>
 5a8:	c8 2f       	mov	r28, r24
 5aa:	d0 e0       	ldi	r29, 0x00	; 0
		txsize = (((txsize & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_TX_FSR_OFFSET + 1));
 5ac:	dc 2f       	mov	r29, r28
 5ae:	cc 27       	eor	r28, r28
 5b0:	c6 01       	movw	r24, r12
 5b2:	e8 dd       	rcall	.-1072   	; 0x184 <W51_read>
 5b4:	c8 0f       	add	r28, r24
 5b6:	d1 1d       	adc	r29, r1
 5b8:	88 24       	eor	r8, r8
 5ba:	83 94       	inc	r8
 5bc:	68 94       	set
 5be:	99 24       	eor	r9, r9
 5c0:	93 f8       	bld	r9, 3
 5c2:	a4 cf       	rjmp	.-184    	; 0x50c <Send+0xa6>

	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_SEND);							// start the send on its way
	while (W51_read(sockaddr+W5100_CR_OFFSET))  ;												// loop until socket starts the send (blocks!!)

	return  W5100_OK;
}
 5c4:	df 91       	pop	r29
 5c6:	cf 91       	pop	r28
 5c8:	1f 91       	pop	r17
 5ca:	0f 91       	pop	r16
 5cc:	ff 90       	pop	r15
 5ce:	ef 90       	pop	r14
 5d0:	df 90       	pop	r13
 5d2:	cf 90       	pop	r12
 5d4:	bf 90       	pop	r11
 5d6:	af 90       	pop	r10
 5d8:	9f 90       	pop	r9
 5da:	8f 90       	pop	r8
 5dc:	7f 90       	pop	r7
 5de:	6f 90       	pop	r6
 5e0:	5f 90       	pop	r5
 5e2:	4f 90       	pop	r4
 5e4:	3f 90       	pop	r3
 5e6:	2f 90       	pop	r2
 5e8:	08 95       	ret

000005ea <Receive>:

unsigned int Receive(unsigned char sock, unsigned char  *buf, unsigned int  buflen)
{
 5ea:	4f 92       	push	r4
 5ec:	5f 92       	push	r5
 5ee:	6f 92       	push	r6
 5f0:	7f 92       	push	r7
 5f2:	8f 92       	push	r8
 5f4:	9f 92       	push	r9
 5f6:	af 92       	push	r10
 5f8:	bf 92       	push	r11
 5fa:	cf 92       	push	r12
 5fc:	df 92       	push	r13
 5fe:	ef 92       	push	r14
 600:	ff 92       	push	r15
 602:	0f 93       	push	r16
 604:	1f 93       	push	r17
 606:	cf 93       	push	r28
 608:	df 93       	push	r29
	unsigned int	offaddr;
	unsigned int	realaddr;
	unsigned int	sockaddr;
	uint8_t				data[24];
	
	if (sock >= W5100_NUM_SOCKETS)  return  W5100_FAIL;		// ignore illegal conditions
 60a:	82 30       	cpi	r24, 0x02	; 2
 60c:	08 f0       	brcs	.+2      	; 0x610 <Receive+0x26>
 60e:	60 c0       	rjmp	.+192    	; 0x6d0 <Receive+0xe6>
 610:	c4 2e       	mov	r12, r20
 612:	d5 2e       	mov	r13, r21
 614:	9f ef       	ldi	r25, 0xFF	; 255
 616:	c9 16       	cp	r12, r25
 618:	91 e0       	ldi	r25, 0x01	; 1
 61a:	d9 06       	cpc	r13, r25
 61c:	30 f0       	brcs	.+12     	; 0x62a <Receive+0x40>
 61e:	0f 2e       	mov	r0, r31
 620:	fe ef       	ldi	r31, 0xFE	; 254
 622:	cf 2e       	mov	r12, r31
 624:	dd 24       	eor	r13, r13
 626:	d3 94       	inc	r13
 628:	f0 2d       	mov	r31, r0
	if (buflen > (MAX_BUF - 2))  {
		buflen = MAX_BUF - 2;											// requests that exceed the max are truncated
	}


	sockaddr = W5100_SKT_BASE(sock);																									// calc base addr for this socket
 62a:	c8 2f       	mov	r28, r24
 62c:	d0 e0       	ldi	r29, 0x00	; 0
 62e:	5e 01       	movw	r10, r28
 630:	84 e0       	ldi	r24, 0x04	; 4
 632:	a8 0e       	add	r10, r24
 634:	b1 1c       	adc	r11, r1
 636:	ba 2c       	mov	r11, r10
 638:	aa 24       	eor	r10, r10
	ptr = W51_read(sockaddr+W5100_RX_RD_OFFSET);																			// get the RX read pointer (MSB)
 63a:	35 01       	movw	r6, r10
 63c:	98 e2       	ldi	r25, 0x28	; 40
 63e:	69 0e       	add	r6, r25
 640:	71 1c       	adc	r7, r1
 642:	c3 01       	movw	r24, r6
 644:	9f dd       	rcall	.-1218   	; 0x184 <W51_read>
 646:	e8 2e       	mov	r14, r24
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_RX_RD_OFFSET + 1));		// get LSB and calc offset addr
 648:	25 01       	movw	r4, r10
 64a:	89 e2       	ldi	r24, 0x29	; 41
 64c:	48 0e       	add	r4, r24
 64e:	51 1c       	adc	r5, r1
 650:	c2 01       	movw	r24, r4
 652:	98 dd       	rcall	.-1232   	; 0x184 <W51_read>
		buflen = MAX_BUF - 2;											// requests that exceed the max are truncated
	}


	sockaddr = W5100_SKT_BASE(sock);																									// calc base addr for this socket
	ptr = W51_read(sockaddr+W5100_RX_RD_OFFSET);																			// get the RX read pointer (MSB)
 654:	f1 2c       	mov	r15, r1
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_RX_RD_OFFSET + 1));		// get LSB and calc offset addr
 656:	fe 2c       	mov	r15, r14
 658:	ee 24       	eor	r14, r14
 65a:	e8 0e       	add	r14, r24
 65c:	f1 1c       	adc	r15, r1
	
	//_delay_ms(1);
	
	cnt = 0;
	while (buflen)
 65e:	c1 14       	cp	r12, r1
 660:	d1 04       	cpc	r13, r1
 662:	b9 f0       	breq	.+46     	; 0x692 <Receive+0xa8>
	{
		buflen--;
		realaddr = (W5100_RXBUFADDR + (MAX_MEM * sock)) + (offaddr & W5100_RX_BUF_MASK);
 664:	2c 96       	adiw	r28, 0x0c	; 12
 666:	dc 2f       	mov	r29, r28
 668:	cc 27       	eor	r28, r28
 66a:	dd 0f       	add	r29, r29
 66c:	dd 0f       	add	r29, r29
 66e:	dd 0f       	add	r29, r29
 670:	47 01       	movw	r8, r14
 672:	86 01       	movw	r16, r12
	//_delay_ms(1);
	
	cnt = 0;
	while (buflen)
	{
		buflen--;
 674:	01 50       	subi	r16, 0x01	; 1
 676:	11 09       	sbc	r17, r1
		realaddr = (W5100_RXBUFADDR + (MAX_MEM * sock)) + (offaddr & W5100_RX_BUF_MASK);
 678:	c4 01       	movw	r24, r8
 67a:	97 70       	andi	r25, 0x07	; 7
		data[cnt] = W51_read(realaddr);
 67c:	8c 0f       	add	r24, r28
 67e:	9d 1f       	adc	r25, r29
 680:	81 dd       	rcall	.-1278   	; 0x184 <W51_read>
		
		cnt++;
		offaddr++;
 682:	9f ef       	ldi	r25, 0xFF	; 255
 684:	89 1a       	sub	r8, r25
 686:	99 0a       	sbc	r9, r25
	offaddr = (((ptr & 0x00FF) << 8 ) + W51_read(sockaddr+W5100_RX_RD_OFFSET + 1));		// get LSB and calc offset addr
	
	//_delay_ms(1);
	
	cnt = 0;
	while (buflen)
 688:	01 15       	cp	r16, r1
 68a:	11 05       	cpc	r17, r1
 68c:	99 f7       	brne	.-26     	; 0x674 <Receive+0x8a>
 68e:	ec 0c       	add	r14, r12
 690:	fd 1c       	adc	r15, r13
		
		cnt++;
		offaddr++;
	}
	
	Send(crntSocket, netBuffer, strlen((char *)netBuffer));
 692:	e2 e2       	ldi	r30, 0x22	; 34
 694:	f1 e0       	ldi	r31, 0x01	; 1
 696:	01 90       	ld	r0, Z+
 698:	00 20       	and	r0, r0
 69a:	e9 f7       	brne	.-6      	; 0x696 <Receive+0xac>
 69c:	31 97       	sbiw	r30, 0x01	; 1
 69e:	af 01       	movw	r20, r30
 6a0:	42 52       	subi	r20, 0x22	; 34
 6a2:	51 40       	sbci	r21, 0x01	; 1
 6a4:	62 e2       	ldi	r22, 0x22	; 34
 6a6:	71 e0       	ldi	r23, 0x01	; 1
 6a8:	80 91 21 01 	lds	r24, 0x0121
 6ac:	dc de       	rcall	.-584    	; 0x466 <Send>
	#ifdef DBG
	printf("\n");
	#endif
	
	// Increase the S0_RX_RD value, so it point to the next receive
	W51_write(sockaddr+W5100_RX_RD_OFFSET, (offaddr & 0xFF00) >> 8);			// update RX read offset (MSB)
 6ae:	6f 2d       	mov	r22, r15
 6b0:	c3 01       	movw	r24, r6
 6b2:	38 dd       	rcall	.-1424   	; 0x124 <W51_write>
	W51_write(sockaddr+W5100_RX_RD_OFFSET + 1,(offaddr & 0x00FF));				// update LSB
 6b4:	6e 2d       	mov	r22, r14
 6b6:	c2 01       	movw	r24, r4
 6b8:	35 dd       	rcall	.-1430   	; 0x124 <W51_write>

	// Now Send the RECV command
	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_RECV);								// issue the receive command
 6ba:	60 e4       	ldi	r22, 0x40	; 64
 6bc:	c5 01       	movw	r24, r10
 6be:	01 96       	adiw	r24, 0x01	; 1
 6c0:	31 dd       	rcall	.-1438   	; 0x124 <W51_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 6c2:	85 e3       	ldi	r24, 0x35	; 53
 6c4:	8a 95       	dec	r24
 6c6:	f1 f7       	brne	.-4      	; 0x6c4 <Receive+0xda>
 6c8:	00 00       	nop
	_delay_us(10);																												// wait for receive to start

	return  W5100_OK;
 6ca:	80 e0       	ldi	r24, 0x00	; 0
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	02 c0       	rjmp	.+4      	; 0x6d4 <Receive+0xea>
	unsigned int	offaddr;
	unsigned int	realaddr;
	unsigned int	sockaddr;
	uint8_t				data[24];
	
	if (sock >= W5100_NUM_SOCKETS)  return  W5100_FAIL;		// ignore illegal conditions
 6d0:	8f ef       	ldi	r24, 0xFF	; 255
 6d2:	90 e0       	ldi	r25, 0x00	; 0
	// Now Send the RECV command
	W51_write(sockaddr+W5100_CR_OFFSET, W5100_SKT_CR_RECV);								// issue the receive command
	_delay_us(10);																												// wait for receive to start

	return  W5100_OK;
}
 6d4:	df 91       	pop	r29
 6d6:	cf 91       	pop	r28
 6d8:	1f 91       	pop	r17
 6da:	0f 91       	pop	r16
 6dc:	ff 90       	pop	r15
 6de:	ef 90       	pop	r14
 6e0:	df 90       	pop	r13
 6e2:	cf 90       	pop	r12
 6e4:	bf 90       	pop	r11
 6e6:	af 90       	pop	r10
 6e8:	9f 90       	pop	r9
 6ea:	8f 90       	pop	r8
 6ec:	7f 90       	pop	r7
 6ee:	6f 90       	pop	r6
 6f0:	5f 90       	pop	r5
 6f2:	4f 90       	pop	r4
 6f4:	08 95       	ret

000006f6 <ReceivedSize>:

unsigned int ReceivedSize(unsigned char  sock)
{
 6f6:	0f 93       	push	r16
 6f8:	1f 93       	push	r17
 6fa:	cf 93       	push	r28
 6fc:	df 93       	push	r29
	unsigned int					val;
	unsigned int					sockaddr;

	if (sock >= W5100_NUM_SOCKETS)  return  0;
 6fe:	82 30       	cpi	r24, 0x02	; 2
 700:	98 f4       	brcc	.+38     	; 0x728 <ReceivedSize+0x32>
	sockaddr = W5100_SKT_BASE(sock);						// calc base addr for this socket
 702:	c8 2f       	mov	r28, r24
 704:	d0 e0       	ldi	r29, 0x00	; 0
 706:	24 96       	adiw	r28, 0x04	; 4
 708:	dc 2f       	mov	r29, r28
 70a:	cc 27       	eor	r28, r28
	val = W51_read(sockaddr+W5100_RX_RSR_OFFSET) & 0xff;
 70c:	ce 01       	movw	r24, r28
 70e:	86 96       	adiw	r24, 0x26	; 38
 710:	39 dd       	rcall	.-1422   	; 0x184 <W51_read>
 712:	90 e0       	ldi	r25, 0x00	; 0
	val = (val << 8) + W51_read(sockaddr+W5100_RX_RSR_OFFSET + 1);
 714:	18 2f       	mov	r17, r24
 716:	00 27       	eor	r16, r16
 718:	ce 01       	movw	r24, r28
 71a:	87 96       	adiw	r24, 0x27	; 39
 71c:	33 dd       	rcall	.-1434   	; 0x184 <W51_read>
 71e:	98 01       	movw	r18, r16
 720:	28 0f       	add	r18, r24
 722:	31 1d       	adc	r19, r1
 724:	c9 01       	movw	r24, r18
	return  val;
 726:	02 c0       	rjmp	.+4      	; 0x72c <ReceivedSize+0x36>
unsigned int ReceivedSize(unsigned char  sock)
{
	unsigned int					val;
	unsigned int					sockaddr;

	if (sock >= W5100_NUM_SOCKETS)  return  0;
 728:	80 e0       	ldi	r24, 0x00	; 0
 72a:	90 e0       	ldi	r25, 0x00	; 0
	sockaddr = W5100_SKT_BASE(sock);						// calc base addr for this socket
	val = W51_read(sockaddr+W5100_RX_RSR_OFFSET) & 0xff;
	val = (val << 8) + W51_read(sockaddr+W5100_RX_RSR_OFFSET + 1);
	return  val;
}
 72c:	df 91       	pop	r29
 72e:	cf 91       	pop	r28
 730:	1f 91       	pop	r17
 732:	0f 91       	pop	r16
 734:	08 95       	ret

00000736 <toggleLed>:
	SPI_PORT |= (1<<RESET_BIT);																			//  done with reset, pull the line high
	_delay_ms(100);																									//  let the chip wake up
}

void toggleLed(uint8_t led) {
	switch(led){
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	88 30       	cpi	r24, 0x08	; 8
 73a:	91 05       	cpc	r25, r1
 73c:	50 f5       	brcc	.+84     	; 0x792 <toggleLed+0x5c>
 73e:	fc 01       	movw	r30, r24
 740:	ea 5b       	subi	r30, 0xBA	; 186
 742:	ff 4f       	sbci	r31, 0xFF	; 255
 744:	d7 c0       	rjmp	.+430    	; 0x8f4 <__tablejump2__>
		case 0: LED1_TG; break;
 746:	85 b3       	in	r24, 0x15	; 21
 748:	80 58       	subi	r24, 0x80	; 128
 74a:	85 bb       	out	0x15, r24	; 21
 74c:	08 95       	ret
		case 1: LED2_TG; break;
 74e:	95 b3       	in	r25, 0x15	; 21
 750:	80 e4       	ldi	r24, 0x40	; 64
 752:	89 27       	eor	r24, r25
 754:	85 bb       	out	0x15, r24	; 21
 756:	08 95       	ret
		case 2: LED3_TG; break;
 758:	95 b3       	in	r25, 0x15	; 21
 75a:	80 e2       	ldi	r24, 0x20	; 32
 75c:	89 27       	eor	r24, r25
 75e:	85 bb       	out	0x15, r24	; 21
 760:	08 95       	ret
		case 3: LED4_TG; break;
 762:	95 b3       	in	r25, 0x15	; 21
 764:	80 e1       	ldi	r24, 0x10	; 16
 766:	89 27       	eor	r24, r25
 768:	85 bb       	out	0x15, r24	; 21
 76a:	08 95       	ret
		case 4: LED5_TG; break;
 76c:	95 b3       	in	r25, 0x15	; 21
 76e:	88 e0       	ldi	r24, 0x08	; 8
 770:	89 27       	eor	r24, r25
 772:	85 bb       	out	0x15, r24	; 21
 774:	08 95       	ret
		case 5: LED6_TG; break;
 776:	95 b3       	in	r25, 0x15	; 21
 778:	84 e0       	ldi	r24, 0x04	; 4
 77a:	89 27       	eor	r24, r25
 77c:	85 bb       	out	0x15, r24	; 21
 77e:	08 95       	ret
		case 6: LED7_TG; break;
 780:	95 b3       	in	r25, 0x15	; 21
 782:	82 e0       	ldi	r24, 0x02	; 2
 784:	89 27       	eor	r24, r25
 786:	85 bb       	out	0x15, r24	; 21
 788:	08 95       	ret
		case 7: LED8_TG; break;
 78a:	95 b3       	in	r25, 0x15	; 21
 78c:	81 e0       	ldi	r24, 0x01	; 1
 78e:	89 27       	eor	r24, r25
 790:	85 bb       	out	0x15, r24	; 21
 792:	08 95       	ret

00000794 <LED_Init>:
		default: break;
	}
}


void LED_Init(void) {
 794:	cf 93       	push	r28
	LED1_SET;
 796:	a7 9a       	sbi	0x14, 7	; 20
	LED2_SET;
 798:	a6 9a       	sbi	0x14, 6	; 20
	LED3_SET;
 79a:	a5 9a       	sbi	0x14, 5	; 20
	LED4_SET;
 79c:	a4 9a       	sbi	0x14, 4	; 20
	LED5_SET;
 79e:	a3 9a       	sbi	0x14, 3	; 20
	LED6_SET;
 7a0:	a2 9a       	sbi	0x14, 2	; 20
	LED7_SET;
 7a2:	a1 9a       	sbi	0x14, 1	; 20
	LED8_SET;
 7a4:	a0 9a       	sbi	0x14, 0	; 20
	
	for(uint8_t a = 0; a < MAX_LEDS; a++){
 7a6:	c0 e0       	ldi	r28, 0x00	; 0
		toggleLed(a);
 7a8:	8c 2f       	mov	r24, r28
 7aa:	c5 df       	rcall	.-118    	; 0x736 <toggleLed>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 7ac:	2f ef       	ldi	r18, 0xFF	; 255
 7ae:	89 e6       	ldi	r24, 0x69	; 105
 7b0:	98 e1       	ldi	r25, 0x18	; 24
 7b2:	21 50       	subi	r18, 0x01	; 1
 7b4:	80 40       	sbci	r24, 0x00	; 0
 7b6:	90 40       	sbci	r25, 0x00	; 0
 7b8:	e1 f7       	brne	.-8      	; 0x7b2 <LED_Init+0x1e>
 7ba:	00 c0       	rjmp	.+0      	; 0x7bc <LED_Init+0x28>
 7bc:	00 00       	nop
	LED5_SET;
	LED6_SET;
	LED7_SET;
	LED8_SET;
	
	for(uint8_t a = 0; a < MAX_LEDS; a++){
 7be:	cf 5f       	subi	r28, 0xFF	; 255
 7c0:	c8 30       	cpi	r28, 0x08	; 8
 7c2:	91 f7       	brne	.-28     	; 0x7a8 <LED_Init+0x14>
		toggleLed(a);
		_delay_ms(500);
	}
}
 7c4:	cf 91       	pop	r28
 7c6:	08 95       	ret

000007c8 <SPI_Init>:

void SPI_Init(void){
	
	// Set MOSI (PORTB2),SCK (PORTB1) and PORTB0 (SS) as output, others as input
	SPI_DDR = (1<<SPI_MOSI)|(1<<SPI_SCLK)|(1<<SPI_CS);
 7c8:	87 e0       	ldi	r24, 0x07	; 7
 7ca:	87 bb       	out	0x17, r24	; 23

	// CS pin is not active - Set to High
	SPI_PORT |= (1<<SPI_CS);
 7cc:	c0 9a       	sbi	0x18, 0	; 24

	// Enable SPI, Master Mode 0, set the clock rate fck/2
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
 7ce:	83 e5       	ldi	r24, 0x53	; 83
 7d0:	8d b9       	out	0x0d, r24	; 13
	SPSR |= (1<<SPI2X);
 7d2:	70 9a       	sbi	0x0e, 0	; 14
 7d4:	08 95       	ret

000007d6 <NET_Init>:

	///////////////////////////////////////////////////////////////////////////////////////////////////
}

void NET_Init(void){
	crntSocket = 0;																// magic number! declare the socket number we will use (0-3)
 7d6:	10 92 21 01 	sts	0x0121, r1
	sockaddr = W5100_SKT_BASE(crntSocket);				// calc address of W5100 register set for this socket
 7da:	80 e0       	ldi	r24, 0x00	; 0
 7dc:	94 e0       	ldi	r25, 0x04	; 4
 7de:	90 93 2b 03 	sts	0x032B, r25
 7e2:	80 93 2a 03 	sts	0x032A, r24
	
	cb._select = &selectEthernet;									// callback for selecting the W5100
 7e6:	e2 e2       	ldi	r30, 0x22	; 34
 7e8:	f3 e0       	ldi	r31, 0x03	; 3
 7ea:	87 e8       	ldi	r24, 0x87	; 135
 7ec:	91 e0       	ldi	r25, 0x01	; 1
 7ee:	91 83       	std	Z+1, r25	; 0x01
 7f0:	80 83       	st	Z, r24
	cb._xchg = &xchgData;													// callback for exchanging data
 7f2:	8b e8       	ldi	r24, 0x8B	; 139
 7f4:	91 e0       	ldi	r25, 0x01	; 1
 7f6:	93 83       	std	Z+3, r25	; 0x03
 7f8:	82 83       	std	Z+2, r24	; 0x02
	cb._deselect = &deselectEthernet;							// callback for de-selecting the W5100
 7fa:	89 e8       	ldi	r24, 0x89	; 137
 7fc:	91 e0       	ldi	r25, 0x01	; 1
 7fe:	95 83       	std	Z+5, r25	; 0x05
 800:	84 83       	std	Z+4, r24	; 0x04
	cb._reset = &resetEthernet;										// callback for hardware-reset of the W5100
 802:	80 e9       	ldi	r24, 0x90	; 144
 804:	91 e0       	ldi	r25, 0x01	; 1
 806:	97 83       	std	Z+7, r25	; 0x07
 808:	86 83       	std	Z+6, r24	; 0x06
	
	W51_register(&cb);														// register our target-specific W5100 routines with the W5100 library
 80a:	cf 01       	movw	r24, r30
 80c:	66 dc       	rcall	.-1844   	; 0xda <W51_register>
	W51_init();																		// now initialize the W5100
 80e:	ea dc       	rcall	.-1580   	; 0x1e4 <W51_init>

	W51_config(&ipConfig);												// config the W5100 (MAC, TCP address, subnet, etc
 810:	80 e0       	ldi	r24, 0x00	; 0
 812:	91 e0       	ldi	r25, 0x01	; 1
 814:	fa cc       	rjmp	.-1548   	; 0x20a <W51_config>
 816:	08 95       	ret

00000818 <SetupHardware>:
	return 0;
}

void SetupHardware(void)
{	
	LED_Init();
 818:	bd df       	rcall	.-134    	; 0x794 <LED_Init>
 81a:	2f ef       	ldi	r18, 0xFF	; 255
 81c:	81 ee       	ldi	r24, 0xE1	; 225
 81e:	94 e0       	ldi	r25, 0x04	; 4
 820:	21 50       	subi	r18, 0x01	; 1
 822:	80 40       	sbci	r24, 0x00	; 0
 824:	90 40       	sbci	r25, 0x00	; 0
 826:	e1 f7       	brne	.-8      	; 0x820 <SetupHardware+0x8>
 828:	00 c0       	rjmp	.+0      	; 0x82a <SetupHardware+0x12>
 82a:	00 00       	nop
	
	_delay_ms(100);
	SPI_Init();
 82c:	cd df       	rcall	.-102    	; 0x7c8 <SPI_Init>
 82e:	2f ef       	ldi	r18, 0xFF	; 255
 830:	83 ed       	ldi	r24, 0xD3	; 211
 832:	90 e3       	ldi	r25, 0x30	; 48
 834:	21 50       	subi	r18, 0x01	; 1
 836:	80 40       	sbci	r24, 0x00	; 0
 838:	90 40       	sbci	r25, 0x00	; 0
 83a:	e1 f7       	brne	.-8      	; 0x834 <SetupHardware+0x1c>
 83c:	00 c0       	rjmp	.+0      	; 0x83e <SetupHardware+0x26>
 83e:	00 00       	nop
	
	_delay_ms(1000);
	NET_Init();
 840:	ca cf       	rjmp	.-108    	; 0x7d6 <NET_Init>
 842:	08 95       	ret

00000844 <runNet>:

	W51_config(&ipConfig);												// config the W5100 (MAC, TCP address, subnet, etc
}

void runNet(void){
	switch  (W51_read(sockaddr+W5100_SR_OFFSET))		// based on current status of socket...
 844:	80 91 2a 03 	lds	r24, 0x032A
 848:	90 91 2b 03 	lds	r25, 0x032B
 84c:	03 96       	adiw	r24, 0x03	; 3
 84e:	9a dc       	rcall	.-1740   	; 0x184 <W51_read>
 850:	88 31       	cpi	r24, 0x18	; 24
 852:	09 f4       	brne	.+2      	; 0x856 <runNet+0x12>
 854:	48 c0       	rjmp	.+144    	; 0x8e6 <runNet+0xa2>
 856:	28 f4       	brcc	.+10     	; 0x862 <runNet+0x1e>
 858:	88 23       	and	r24, r24
 85a:	41 f0       	breq	.+16     	; 0x86c <runNet+0x28>
 85c:	87 31       	cpi	r24, 0x17	; 23
 85e:	c9 f0       	breq	.+50     	; 0x892 <runNet+0x4e>
 860:	08 95       	ret
 862:	8a 51       	subi	r24, 0x1A	; 26
 864:	84 30       	cpi	r24, 0x04	; 4
 866:	08 f0       	brcs	.+2      	; 0x86a <runNet+0x26>
 868:	41 c0       	rjmp	.+130    	; 0x8ec <runNet+0xa8>
 86a:	3d c0       	rjmp	.+122    	; 0x8e6 <runNet+0xa2>
	{
		case  W5100_SKT_SR_CLOSED:						// if socket is closed...
			if (Connect(crntSocket, srvrIp, W5100_SKT_MR_TCP, SRVR_PORT) == crntSocket)		// if successful opening a socket...
 86c:	28 e5       	ldi	r18, 0x58	; 88
 86e:	37 e0       	ldi	r19, 0x07	; 7
 870:	41 e0       	ldi	r20, 0x01	; 1
 872:	62 e1       	ldi	r22, 0x12	; 18
 874:	71 e0       	ldi	r23, 0x01	; 1
 876:	80 91 21 01 	lds	r24, 0x0121
 87a:	7a dd       	rcall	.-1292   	; 0x370 <Connect>
 87c:	90 91 21 01 	lds	r25, 0x0121
 880:	89 13       	cpse	r24, r25
 882:	34 c0       	rjmp	.+104    	; 0x8ec <runNet+0xa8>
 884:	8f e9       	ldi	r24, 0x9F	; 159
 886:	9f e0       	ldi	r25, 0x0F	; 15
 888:	01 97       	sbiw	r24, 0x01	; 1
 88a:	f1 f7       	brne	.-4      	; 0x888 <runNet+0x44>
 88c:	00 c0       	rjmp	.+0      	; 0x88e <runNet+0x4a>
 88e:	00 00       	nop
 890:	08 95       	ret
		case  W5100_SKT_SR_INIT: {
			break;
		}
		
		case  W5100_SKT_SR_ESTABLISHED:					// if socket connection is established...
			rsize = ReceivedSize(crntSocket);					// find out how many bytes
 892:	80 91 21 01 	lds	r24, 0x0121
 896:	2f df       	rcall	.-418    	; 0x6f6 <ReceivedSize>
 898:	90 93 20 01 	sts	0x0120, r25
 89c:	80 93 1f 01 	sts	0x011F, r24
			if (rsize >= 1) {
 8a0:	00 97       	sbiw	r24, 0x00	; 0
 8a2:	e1 f0       	breq	.+56     	; 0x8dc <runNet+0x98>
				if (Receive(crntSocket, netBuffer, rsize) != W5100_OK)  {
 8a4:	ac 01       	movw	r20, r24
 8a6:	62 e2       	ldi	r22, 0x22	; 34
 8a8:	71 e0       	ldi	r23, 0x01	; 1
 8aa:	80 91 21 01 	lds	r24, 0x0121
 8ae:	9d de       	rcall	.-710    	; 0x5ea <Receive>
 8b0:	89 2b       	or	r24, r25
 8b2:	29 f0       	breq	.+10     	; 0x8be <runNet+0x7a>
					strcpy_P((char *)netBuffer, PSTR("Z"));
 8b4:	6c e9       	ldi	r22, 0x9C	; 156
 8b6:	70 e0       	ldi	r23, 0x00	; 0
 8b8:	82 e2       	ldi	r24, 0x22	; 34
 8ba:	91 e0       	ldi	r25, 0x01	; 1
 8bc:	24 d0       	rcall	.+72     	; 0x906 <strcpy_P>
				}
			
				if (Send(crntSocket, netBuffer, strlen((char *)netBuffer)) == W5100_FAIL)  break;		// just throw out the packet for now
 8be:	e2 e2       	ldi	r30, 0x22	; 34
 8c0:	f1 e0       	ldi	r31, 0x01	; 1
 8c2:	01 90       	ld	r0, Z+
 8c4:	00 20       	and	r0, r0
 8c6:	e9 f7       	brne	.-6      	; 0x8c2 <runNet+0x7e>
 8c8:	31 97       	sbiw	r30, 0x01	; 1
 8ca:	af 01       	movw	r20, r30
 8cc:	42 52       	subi	r20, 0x22	; 34
 8ce:	51 40       	sbci	r21, 0x01	; 1
 8d0:	62 e2       	ldi	r22, 0x22	; 34
 8d2:	71 e0       	ldi	r23, 0x01	; 1
 8d4:	80 91 21 01 	lds	r24, 0x0121
 8d8:	c6 cd       	rjmp	.-1140   	; 0x466 <Send>
 8da:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 8dc:	95 e3       	ldi	r25, 0x35	; 53
 8de:	9a 95       	dec	r25
 8e0:	f1 f7       	brne	.-4      	; 0x8de <runNet+0x9a>
 8e2:	00 00       	nop
 8e4:	08 95       	ret
		case  W5100_SKT_SR_FIN_WAIT:
		case  W5100_SKT_SR_CLOSING:
		case  W5100_SKT_SR_TIME_WAIT:
		case  W5100_SKT_SR_CLOSE_WAIT:
		case  W5100_SKT_SR_LAST_ACK: {
			Close(crntSocket);
 8e6:	80 91 21 01 	lds	r24, 0x0121
 8ea:	2e cd       	rjmp	.-1444   	; 0x348 <Close>
 8ec:	08 95       	ret

000008ee <main>:
#include <client.h>

int main (void)
{
	SetupHardware();
 8ee:	94 df       	rcall	.-216    	; 0x818 <SetupHardware>
	
	for(;;){
		runNet();
 8f0:	a9 df       	rcall	.-174    	; 0x844 <runNet>
	}
 8f2:	fe cf       	rjmp	.-4      	; 0x8f0 <main+0x2>

000008f4 <__tablejump2__>:
 8f4:	ee 0f       	add	r30, r30
 8f6:	ff 1f       	adc	r31, r31
 8f8:	00 24       	eor	r0, r0
 8fa:	00 1c       	adc	r0, r0
 8fc:	0b be       	out	0x3b, r0	; 59
 8fe:	07 90       	elpm	r0, Z+
 900:	f6 91       	elpm	r31, Z
 902:	e0 2d       	mov	r30, r0
 904:	09 94       	ijmp

00000906 <strcpy_P>:
 906:	fb 01       	movw	r30, r22
 908:	dc 01       	movw	r26, r24
 90a:	05 90       	lpm	r0, Z+
 90c:	0d 92       	st	X+, r0
 90e:	00 20       	and	r0, r0
 910:	e1 f7       	brne	.-8      	; 0x90a <strcpy_P+0x4>
 912:	08 95       	ret

00000914 <_exit>:
 914:	f8 94       	cli

00000916 <__stop_program>:
 916:	ff cf       	rjmp	.-2      	; 0x916 <__stop_program>
